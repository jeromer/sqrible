// +---------------- DO NO EDIT ! ---------------- +
// |      This file was generated by sqrible       |
// +---------------------------------------------- +

package user

import (
	"errors"
	"models/base"
	"strings"
)

var ErrNotFound = errors.New("row not found in users")

type User struct {
	ID pgtype.Int8 // users.id(bigint)

	UID pgtype.Text // users.uid(text)

	Email pgtype.Text // users.email(text)

	EmailConfirmed pgtype.Bool // users.email_confirmed(boolean)

	CreationDate pgtype.Timestamptz // users.creation_date(timestamp with time zone)

	UpdateDate pgtype.Timestamptz // users.update_date(timestamp with time zone)

	AvatarFileName pgtype.Text // users.avatar_file_name(text)

	Twitter pgtype.Text // users.twitter(text)

	Facebook pgtype.Text // users.facebook(text)

	Gplus pgtype.Text // users.gplus(text)

}

func TableName() string {
	return "users"
}

func StructScan(r *pgx.Row, x *User) error {
	return r.Scan(

		&(x.ID),

		&(x.UID),

		&(x.Email),

		&(x.EmailConfirmed),

		&(x.CreationDate),

		&(x.UpdateDate),

		&(x.AvatarFileName),

		&(x.Twitter),

		&(x.Facebook),

		&(x.Gplus),
	)
}

func StructScanRows(rows *pgx.Rows) ([]*User, error) {
	defer rows.Close()

	var buff []*User

	var err error

	for rows.Next() {
		x := New()
		err = rows.Scan(

			&(x.ID),

			&(x.UID),

			&(x.Email),

			&(x.EmailConfirmed),

			&(x.CreationDate),

			&(x.UpdateDate),

			&(x.AvatarFileName),

			&(x.Twitter),

			&(x.Facebook),

			&(x.Gplus),
		)

		if err != nil {
			return []*User{}, err
		}

		buff = append(buff, x)
	}

	return buff, err
}

func insert(db base.Queryer, x *User) (*User, error) {
	args := pgx.QueryArgs(make([]interface{}, 0, 12))

	var columns, values []string

	if x.Email.Status != pgtype.Undefined {
		columns = append(columns, `email`)
		values = append(values, args.Append(&(x.Email)))
	}

	if x.Username.Status != pgtype.Undefined {
		columns = append(columns, `username`)
		values = append(values, args.Append(&(x.Username)))
	}

	if x.EmailConfirmed.Status != pgtype.Undefined {
		columns = append(columns, `email_confirmed`)
		values = append(values, args.Append(&(x.EmailConfirmed)))
	}

	if x.UpdateDate.Status != pgtype.Undefined {
		columns = append(columns, `update_date`)
		values = append(values, args.Append(&(x.UpdateDate)))
	}

	if x.AvatarFileName.Status != pgtype.Undefined {
		columns = append(columns, `avatar_file_name`)
		values = append(values, args.Append(&(x.AvatarFileName)))
	}

	if x.Twitter.Status != pgtype.Undefined {
		columns = append(columns, `twitter`)
		values = append(values, args.Append(&(x.Twitter)))
	}

	if x.Facebook.Status != pgtype.Undefined {
		columns = append(columns, `facebook`)
		values = append(values, args.Append(&(x.Facebook)))
	}

	if x.Gplus.Status != pgtype.Undefined {
		columns = append(columns, `gplus`)
		values = append(values, args.Append(&(x.Gplus)))
	}

	sql := `INSERT INTO "users" (` + strings.Join(columns, ", ") + `)
			VALUES(` + strings.Join(values, ",") + `)
			RETURNING id, uid, email, email_confirmed, creation_date, update_date, avatar_file_name, twitter, facebook, gplus;`

	stmtName := base.PreparedName("SqribleInsertUser", sql)

	x2 := New()
	err := StructScan(
		base.PrepareQueryRow(db, stmtName, sql, args...), x2,
	)

	if err != nil {
		return nil, err
	}

	return x2, err
}

func update(db base.Queryer, x *User) (*User, error) {
	sets := make([]string, 0, 8)
	args := pgx.QueryArgs(make([]interface{}, 0, 9))

	if x.Email.Status != pgtype.Undefined {
		sets = append(sets, `email`+"="+args.Append(&(x.Email)))
	}

	if x.Enabled.Status != pgtype.Undefined {
		sets = append(sets, `enabled`+"="+args.Append(&(x.Enabled)))
	}

	if x.EmailConfirmed.Status != pgtype.Undefined {
		sets = append(sets, `email_confirmed`+"="+args.Append(&(x.EmailConfirmed)))
	}

	if x.UpdateDate.Status != pgtype.Undefined {
		sets = append(sets, `update_date`+"="+args.Append(&(x.UpdateDate)))
	}

	if x.AvatarFileName.Status != pgtype.Undefined {
		sets = append(sets, `avatar_file_name`+"="+args.Append(&(x.AvatarFileName)))
	}

	if x.Twitter.Status != pgtype.Undefined {
		sets = append(sets, `twitter`+"="+args.Append(&(x.Twitter)))
	}

	if x.Facebook.Status != pgtype.Undefined {
		sets = append(sets, `facebook`+"="+args.Append(&(x.Facebook)))
	}

	if x.Gplus.Status != pgtype.Undefined {
		sets = append(sets, `gplus`+"="+args.Append(&(x.Gplus)))
	}

	if len(sets) == 0 {
		return x, nil
	}

	sql := `UPDATE "users" SET ` + strings.Join(sets, ", ")
	sql += ` WHERE `
	sql +=
		`id=` + args.Append(&(x.ID))

	sql += ` RETURNING id, uid, email, email_confirmed, creation_date, update_date, avatar_file_name, twitter, facebook, gplus;`

	stmtName := base.PreparedName("sqribleUpdateUser", sql)

	x2 := New()
	err := StructScan(
		base.PrepareQueryRow(db, stmtName, sql, args...), x2,
	)

	if err != nil {
		return nil, err
	}

	return x2, err
}

func Count(db base.Queryer) int {
	var n int

	sql := "SELECT COUNT(*) FROM users"

	stmtName := base.PreparedName("SqribleCountUser", sql)
	err := base.PrepareQueryRow(db, stmtName, sql).Scan(&n)

	if err != nil {
		return 0
	}

	return n
}

func fetchOne(db base.Queryer, fieldName string, fieldValue interface{}) (*User, error) {
	sql := `SELECT id, uid, email, email_confirmed, creation_date, update_date, avatar_file_name, twitter, facebook, gplus
          FROM users
          WHERE ` + fieldName + `=$1;`

	stmtName := base.PreparedName(
		"sqribleFetchOneUserBy"+fieldName, sql,
	)

	x := New()

	err := StructScan(
		base.PrepareQueryRow(db, stmtName, sql, fieldValue), x,
	)

	if err == pgx.ErrNoRows {
		return nil, ErrNotFound
	} else if err != nil {
		return nil, err
	}

	return x, nil
}

func fetchOneWithSQL(db base.Queryer, sql string, args ...interface{}) (*User, error) {
	stmtName := base.PreparedName(
		"sqribleFetchOneWithSQLUser", sql,
	)

	x := New()

	err := StructScan(
		base.PrepareQueryRow(db, stmtName, sql, args...), x,
	)

	if err == pgx.ErrNoRows {
		return nil, ErrNotFound
	} else if err != nil {
		return nil, err
	}

	return x, nil
}
